{
	"Input": {
		"scope": "csharp",
		"prefix": "instr",
		"body": [
			"var ${1:val} = Console.ReadLine();"
		],
		"description": "Input string from console"
	},
	"InputNumber": {
		"scope": "csharp",
		"prefix": "innum",
		"body": [
			"var ${1:val} = int.Parse(Console.ReadLine());"
		],
		"description": "Input number from console"
	},
	"InputCharacterArray": {
		"scope": "csharp",
		"prefix": "instrarr",
		"body": [
			"var ${1:val} = Console.ReadLine().Trim().Split(' ');"
		],
		"description": "Input char array from console"
	},
	"InputNumberArray": {
		"scope": "csharp",
		"prefix": "innumarr",
		"body": [
			"var ${1:val} = Console.ReadLine().Trim().Split(' ').Select(${2:int}.Parse).ToArray();"
		],
		"description": "Input number array from console"
	},
	"Scan1": {
		"scope": "csharp",
		"prefix": "scan1",
		"body": [
			"var ${1:val} = Scanner.Scan<${2:int}>();"
		],
		"description": "Scan value"
	},
	"Scan2": {
		"scope": "csharp",
		"prefix": "scan2",
		"body": [
			"var (${1:val1}, ${3:val2}) = Scanner.Scan<${2:int}, ${4:int}>();"
		],
		"description": "Scan 2 values"
	},
	"Scan3": {
		"scope": "csharp",
		"prefix": "scan3",
		"body": [
			"var (${1:val1}, ${3:val2}, ${5:val3}) = Scanner.Scan<${2:int}, ${4:int}, ${6:int}>();"
		],
		"description": "Scan 3 values"
	},
	"Scan4": {
		"scope": "csharp",
		"prefix": "scan4",
		"body": [
			"var (${1:val1}, ${3:val2}, ${5:val3}, ${7:val4}) = Scanner.Scan<${2:int}, ${4:int}, ${6:int}, ${8:int}>();"
		],
		"description": "Scan 4 values"
	},
	"Scan5": {
		"scope": "csharp",
		"prefix": "scan5",
		"body": [
			"var (${1:val1}, ${3:val2}, ${5:val3}, ${7:val4}, ${9:val5}) = Scanner.Scan<${2:int}, ${4:int}, ${6:int}, ${8:int}, ${10:int}>();"
		],
		"description": "Scan 5 values"
	},
	"Scan6": {
		"scope": "csharp",
		"prefix": "scan6",
		"body": [
			"var (${1:val1}, ${3:val2}, ${5:val3}, ${7:val4}, ${9:val5}, ${11:val6}) = Scanner.Scan<${2:int}, ${4:int}, ${6:int}, ${8:int}, ${10:int}, ${12:int}>();"
		],
		"description": "Scan 6 values"
	},
	"ScanArray": {
		"scope": "csharp",
		"prefix": "scanarray",
		"body": [
			"var ${1:array} = Scanner.ScanEnumerable<${2:int}>().ToArray();"
		],
		"description": "Scan values as array"
	},
	"ScanList": {
		"scope": "csharp",
		"prefix": "scanlist",
		"body": [
			"var ${1:list} = Scanner.ScanEnumerable<${2:int}>().ToList();"
		],
		"description": "Scan values as list"
	},
	"GreatestCommonDivisor": {
		"scope": "csharp",
		"prefix": [
			"gcd",
			"greatestcommondivisor"
		],
		"body": [
			"private static long GreatestCommonDivisor(long a, long b)",
			"{",
			"    while (true)",
			"    {",
			"        if (b == 0) return a;",
			"        (a, b) = (b, a % b);",
			"    }",
			"}"
		],
		"description": "Method of the greatest common divisor number"
	},
	"LeastCommonMultiple": {
		"scope": "csharp",
		"prefix": [
			"lcm",
			"leastcommonmultiple"
		],
		"body": [
			"public static long LeastCommonMultiple(long a, long b) => a * b / GreatestCommonDivisor(a, b);"
		],
		"description": "Method of the least common multiple number"
	},
	"Enumeration": {
		"scope": "csharp",
		"prefix": "enumeration",
		"body": [
			"public static class Enumeration",
			"{",
			"    private static Dictionary<long, long> _memo = new Dictionary<long, long> { { 0, 1 }, { 1, 1 } };",
			"    private static Dictionary<long, long> _modMemo = new Dictionary<long, long> { { 0, 1 }, { 1, 1 } };",
			"    private static long _max = 1;",
			"    private static long _modMax = 1;",
			"",
			"    public static long Factorial(long n)",
			"    {",
			"        if (_memo.ContainsKey(n)) return _memo[n];",
			"        if (n < 0) throw new ArgumentException();",
			"        var val = _memo[_max];",
			"        for (var i = _max + 1; i <= n; i++)",
			"        {",
			"            val *= i;",
			"            _memo[i] = val;",
			"        }",
			"        _max = n;",
			"        return _memo[n];",
			"    }",
			"",
			"    public static long Factorial(long n, long mod)",
			"    {",
			"        if (_modMemo.ContainsKey(n)) return _modMemo[n];",
			"        if (n < 0) throw new ArgumentException();",
			"        var val = _modMemo[_modMax];",
			"        for (var i = _modMax + 1; i <= n; i++)",
			"        {",
			"            val *= i % mod;",
			"            val %= mod;",
			"            _modMemo[i] = val;",
			"        }",
			"        _modMax = n;",
			"        return _modMemo[n];",
			"    }",
			"",
			"    public static long PermutationCount(long n, long k)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        return Factorial(n) / Factorial(n - k);",
			"        // no memo",
			"        // var ret = 1L;",
			"        // for (var i = 0; i < k; i++) ret *= (n - i);",
			"        // return ret;",
			"    }",
			"",
			"    public static long PermutationCount(long n, long k, long mod)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        var top = Factorial(n, mod);",
			"        var bottom = Factorial(n - k, mod);",
			"        return (top * Power(bottom, mod - 2, mod)) % mod;",
			"        // no memo",
			"        // var ret = 1L;",
			"        // for (var i = 0; i < k; i++) ret = (ret * (n - i) % mod) % mod;",
			"        // return ret;",
			"    }",
			"",
			"    public static long CombinationCount(long n, long k)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        k = Math.Min(k, n - k);",
			"        return Factorial(n) / (Factorial(k) * Factorial(n - k));",
			"        // no memo",
			"        // return PermutationCount(n, k) / PermutationCount(k, k);",
			"    }",
			"",
			"    public static long CombinationCount(long n, long k, long mod)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        k = Math.Min(k, n - k);",
			"        var top = Factorial(n, mod);",
			"        var bottom = (Factorial(k, mod) * Factorial(n - k, mod)) % mod;",
			"        // no memo",
			"        // var top = PermutationCount(n, k, mod);",
			"        // var bottom = PermutationCount(k, k, mod);",
			"        return (top * Power(bottom, mod - 2, mod)) % mod;",
			"    }",
			"",
			"    public static long Power(long x, long y, long mod)",
			"    {",
			"        var result = 1L;",
			"        while (y > 0)",
			"        {",
			"            var xmod = x % mod;",
			"            if ((y & 1) == 1) result = (result * xmod) % mod;",
			"            x = (xmod * xmod) % mod;",
			"            y >>= 1;",
			"        }",
			"        return result;",
			"    }",
			"}"
		],
		"description": "Utility of enumeration"
	},
	"BinarySearch": {
		"scope": "csharp",
		"prefix": [
			"binarysearch",
			"bs"
		],
		"body": [
			"public static bool BinarySearch<T>(IReadOnlyList<T> items, T key, Comparer<T> comparer = null)",
			"{",
			"    comparison ??= Comparer<T>.Default.Compare;",
			"    var (l, r) = (0, items.Count);",
			"    while (r - l > 1)",
			"    {",
			"        var m = (l + r) / 2;",
			"        var result = comparison(items[m], key);",
			"        if (result < 0) l = m;",
			"        else if (result > 0) r = m;",
			"        else true;",
			"    }",
			"    return false;",
			"}"
		],
		"description": "Binary search"
	},
	"LowerBound": {
		"scope": "csharp",
		"prefix": [
			"lowerbound",
			"lb",
		],
		"body": [
			"public static int LowerBound<T>(IReadOnlyList<T> items, T key, Comparison<T> comparison = null)",
			"{",
			"    comparison ??= Comparer<T>.Default.Compare;",
			"    var (l, r) = (0, items.Count);",
			"    while (r - l > 1)",
			"    {",
			"        var m = (l + r) / 2;",
			"        if (comparison(items[m], key) < 0) l = m;",
			"        else r = m;",
			"    }",
			"    return r;",
			"}"
		],
		"description": "Lower bound"
	},
	"UpperBound": {
		"scope": "csharp",
		"prefix": [
			"upperbound",
			"ub",
		],
		"body": [
			"public static int UpperBound<T>(IReadOnlyList<T> items, T key, Comparison<T> comparison = null)",
			"{",
			"    comparison ??= Comparer<T>.Default.Compare;",
			"    var (l, r) = (0, items.Count);",
			"    while (r - l > 1)",
			"    {",
			"        var m = (l + r) / 2;",
			"        if (comparison(items[m], key) <= 0) l = m;",
			"        else r = m;",
			"    }",
			"    return r;",
			"}"
		],
		"description": "Upper bound"
	},
	"CumulativeSum": {
		"scope": "csharp",
		"prefix": "cumlate",
		"body": [
			"public static IEnumerable<TAccumulate> Cumulate<TSource, TAccumulate>(IEnumerable<TSource> source,",
			"    TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)",
			"{",
			"    if (source == null) throw new ArgumentNullException(nameof(source));",
			"    if (func == null) throw new ArgumentNullException(nameof(func));",
			"    yield return seed;",
			"    using var enumerator = source.GetEnumerator();",
			"    while (enumerator.MoveNext()) yield return seed = func(seed, enumerator.Current);",
			"}",
			"",
			"public static IEnumerable<TAccumulate> Cumulate<TSource, TAccumulate>(IEnumerable<TSource> source,",
			"    Func<TAccumulate, TSource, TAccumulate> func) => Cumulate(source, default, func);",
			"public static IEnumerable<TSource> Cumulate<TSource>(IEnumerable<TSource> source,",
			"    Func<TSource, TSource, TSource> func) => Cumulate(source, default, func);"
		],
		"description": "Cumulatie items"
	},
	"CountOf": {
		"scope": "csharp",
		"prefix": "countof",
		"body": [
			"static int CountOf(string target, string value)",
			"{",
			"    var editStr = target;",
			"    var count = 0;",
			"    var index = 0;",
			"    while (true)",
			"    {",
			"        index = editStr.IndexOf(value);",
			"        if (index < 0) break;",
			"        count++;",
			"        if (editStr.Length > 1) editStr = editStr.Substring(index + 1);",
			"    }",
			"    return count;",
			"}"
		],
		"description": "Count of a substring in a string"
	},
	"Prime": {
		"scope": "csharp",
		"prefix": "prime",
		"body": [
			"public static class Prime",
			"{",
			"    public static IDictionary<int, int> GetFactors(int value)",
			"    {",
			"        var factors = new Dictionary<int, int>();",
			"        if (value < 2) return factors;",
			"        for (var i = 2; i * i <= value; i++)",
			"        {",
			"            if (value % i != 0) continue;",
			"            factors[i] = 0;",
			"            while (value % i == 0)",
			"            {",
			"                value /= i;",
			"                factors[i]++;",
			"            }",
			"        }",
			"",
			"        if (value > 1) factors[value] = 1;",
			"        return factors;",
			"    }",
			"",
			"    public static int[] GetPrimes(int value)",
			"    {",
			"        if (value < 2) return new int[0];",
			"        if (value == 2) return new[] {2};",
			"        const int bit = 32;",
			"        const int limit = 1024;",
			"        value = (value + 1) / 2;",
			"        var length = (value + bit) / bit;",
			"        var sieve = length < limit ? stackalloc uint[length] : new uint[length];",
			"        for (var i = value % bit; i < bit; i++) sieve[^1] |= 1U << i;",
			"        for (var i = 1; i * i <= value;)",
			"        {",
			"            for (var j = i; j <= value; j += i * 2 + 1) sieve[j / bit] |= 1U << (j % bit);",
			"            sieve[i / bit] &= ~(1U << (i % bit));",
			"            do i++;",
			"            while (i * i <= value && (sieve[i / bit] >> (i % bit) & 1) == 1);",
			"        }",
			"",
			"        var count = bit * length;",
			"        foreach (var flags in sieve) count -= BitOperations.PopCount(flags);",
			"        var primes = count < limit ? stackalloc int[count] : new int[count];",
			"        primes[0] = 2;",
			"        var index = 1;",
			"        for (var i = 1; index < count && i <= value; i++)",
			"            if ((sieve[i / bit] >> (i % bit) & 1U) == 0)",
			"                primes[index++] = i * 2 + 1;",
			"        return primes.ToArray();",
			"    }",
			"",
			"    public static bool IsPrime(int value)",
			"    {",
			"        if (value == 2) return true;",
			"        if (value < 2 || value % 2 == 0) return false;",
			"        if (value < 2e5)",
			"        {",
			"            for (var i = 3; i * i <= value; i += 2)",
			"                if (value % i == 0)",
			"                    return false;",
			"            return true;",
			"        }",
			"",
			"        long d = value - 1;",
			"        d /= d & -d;",
			"        foreach (var w in stackalloc long[] {2, 7, 61})",
			"        {",
			"            var a = 1L;",
			"            var t = d;",
			"            var m = w;",
			"            while (t > 0)",
			"            {",
			"                if (t % 2 == 1) a = a * m % value;",
			"                m = m * m % value;",
			"                t >>= 1;",
			"            }",
			"",
			"            t = d;",
			"            while (t != value - 1 && a != 1 && a != value - 1)",
			"            {",
			"                a = a * a % value;",
			"                t <<= 1;",
			"            }",
			"",
			"            if (w % value != 0 && a != value - 1 && t % 2 == 0) return false;",
			"        }",
			"",
			"        return true;",
			"    }",
			"}"
		],
		"description": "Prime utilities"
	},
	"GetDivisors": {
		"scope": "csharp",
		"prefix": "getdivisors",
		"body": [
			"public static IEnumerable<long> GetDivisors(long n)",
			"{",
			"    for (var i = 1L; i * i <= n; i++)",
			"    {",
			"        if (n % i != 0) continue;",
			"        yield return i;",
			"        if (n / i != i) yield return n / i;",
			"    }",
			"}"
		],
		"description": "Get divisors of n"
	},
	"Graph": {
		"scope": "csharp",
		"prefix": "graph",
		"body": [
			"var G = new List<${2:int}>[${1:N}].Select(x => new List<${2}>()).ToArray();",
			"for (var i = 0; i < ${3:M}; i++)",
			"{",
			"    var (${4:a}, ${5:b}) = Scanner.Scan<${2}, ${2}>();",
			"    G[--${4}].Add(--${5});",
			"    G[${5}].Add(${4});",
			"}"
		],
		"description": "graph"
	},
	"Bfs": {
		"scope": "csharp",
		"prefix": "bfs",
		"body": [
			"var queue = new Queue<int>();",
			"queue.Enqueue(0);",
			"var depths = Enumerable.Repeat(-1, ${1:N}).ToArray();",
			"depths[0] = 0;",
			"while (queue.Any())",
			"{",
			"    var current = queue.Dequeue();",
			"    foreach (var next in G[current])",
			"    {",
			"        if (depths[next] != -1) continue;",
			"        depths[next] = depths[current] + 1;",
			"        queue.Enqueue(next);",
			"    }",
			"}"
		],
		"description": "breadth first search"
	},
	"Intersect": {
		"scope": "csharp",
		"prefix": "intersect",
		"body": [
			"public static bool Intersect(long ax, long ay, long bx, long by, long cx, long cy, long dx, long dy)",
			"{",
			"    var ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);",
			"    var tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);",
			"    var tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);",
			"    var td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);",
			"    return ta * tb < 0 && tc * td < 0;",
			"}"
		],
		"description": "check the lines are crossing."
	},
	"Xor0To": {
		"scope": "csharp",
		"prefix": "xor0to",
		"body": [
			"public static long Xor0To(long x)",
			"{",
			"    if (x < 0) return 0;",
			"    return (x % 4) switch",
			"    {",
			"        0 => x,",
			"        1 => 1,",
			"        2 => 1 ^ x,",
			"        _ => 0",
			"    };",
			"}"
		],
		"description": "Aggregate xor values"
	},
	"For": {
		"scope": "csharp",
		"prefix": "for",
		"body": [
			"for (var ${1:i} = ${2:0}; ${1} < ${3:end}; ${1}++)",
			"{",
			"    ${4}",
			"}"
		],
		"description": "for statement"
	},
	"Out": {
		"scope": "csharp",
		"prefix": "out",
		"body": [
			"Console.WriteLine(${1});"
		],
		"description": "Output"
	},
	"TestMethod": {
		"scope": "csharp",
		"prefix": "testmethod",
		"body": [
			"[TestMethod]",
			"public void TestMethod${1:number}()",
			"{",
			"    const string input = @\"\";",
			"    const string output = @\"\";",
			"    Tester.InOutTest(() => Tasks.${2:task}.Solve(), input, output);",
			"}"
		],
		"description": "Output"
	},
}