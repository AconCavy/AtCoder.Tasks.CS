{
	"Input": {
		"scope": "csharp",
		"prefix": "instr",
		"body": [
			"var ${1:val} = Console.ReadLine();"
		],
		"description": "Input string from console"
	},
	"InputNumber": {
		"scope": "csharp",
		"prefix": "innum",
		"body": [
			"var ${1:val} = int.Parse(Console.ReadLine());"
		],
		"description": "Input number from console"
	},
	"InputCharacterArray": {
		"scope": "csharp",
		"prefix": "instrarr",
		"body": [
			"var ${1:val} = Console.ReadLine().Trim().Split(' ');"
		],
		"description": "Input char array from console"
	},
	"InputNumberArray": {
		"scope": "csharp",
		"prefix": "innumarr",
		"body": [
			"var ${1:val} = Console.ReadLine().Trim().Split(' ').Select(${2:int}.Parse).ToArray();"
		],
		"description": "Input number array from console"
	},
	"Scan1": {
		"scope": "csharp",
		"prefix": "scan1",
		"body": [
			"var ${1:val} = Scanner.Scan<${2:int}>();"
		],
		"description": "Scan value to 1 variable"
	},
	"Scan2": {
		"scope": "csharp",
		"prefix": "scan2",
		"body": [
			"var (${1:val1}, ${2:val2}) = Scanner.Scan<${3:int}, ${4:int}>();"
		],
		"description": "Scan values to 2 variables"
	},
	"Scan3": {
		"scope": "csharp",
		"prefix": "scan3",
		"body": [
			"var (${1:val1}, ${2:val2}, ${3:val3}) = Scanner.Scan<${4:int}, ${5:int}, ${6:int}>();"
		],
		"description": "Scan values to 3 variables"
	},
	"Scan4": {
		"scope": "csharp",
		"prefix": "scan4",
		"body": [
			"var (${1:val1}, ${2:val2}, ${3:val3}, ${4:val4}) = Scanner.Scan<${5:int}, ${6:int}, ${7:int}, ${8:int}>();"
		],
		"description": "Scan values to 4 variables"
	},
	"Scan5": {
		"scope": "csharp",
		"prefix": "scan5",
		"body": [
			"var (${1:val1}, ${2:val2}, ${3:val3}, ${4:val4}, ${5:val5}) = Scanner.Scan<${6:int}, ${7:int}, ${8:int}, ${9:int}, ${10:int}>();"
		],
		"description": "Scan values to 5 variables"
	},
	"ScanArray": {
		"scope": "csharp",
		"prefix": "scanarray",
		"body": [
			"var ${1:array} = Scanner.ScanEnumerable<${2:int}>().ToArray();"
		],
		"description": "Scan values as array"
	},
	"ScanList": {
		"scope": "csharp",
		"prefix": "scanlist",
		"body": [
			"var ${1:list} = Scanner.ScanEnumerable<${2:int}>().ToList();"
		],
		"description": "Scan values as list"
	},
	"GreatestCommonDivisor": {
		"scope": "csharp",
		"prefix": "gcd",
		"body": [
			"static long GCD(long a, long b) => b == 0 ? a : GCD(b, a % b);"
		],
		"description": "Method of the greatest common divisor number"
	},
	"LeastCommonMultiple": {
		"scope": "csharp",
		"prefix": "lcm",
		"body": [
			"static long LCM(long a, long b) => a * b / GCD(a, b);"
		],
		"description": "Method of the least common multiple number"
	},
	"MInt": {
		"scope": "csharp",
		"prefix": "mint",
		"body": [
			"public readonly struct MInt",
			"{",
			"    public long Value { get; }",
			"    public static long Mod { get; private set; } = 998244353;",
			"",
			"    public MInt(long data) => Value = (0 <= data ? data : data + Mod) % Mod;",
			"    public static implicit operator long(MInt mint) => mint.Value;",
			"    public static implicit operator int(MInt mint) => (int)mint.Value;",
			"    public static implicit operator MInt(long val) => new MInt(val);",
			"    public static implicit operator MInt(int val) => new MInt(val);",
			"    public static MInt operator +(MInt a, MInt b) => a.Value + b.Value;",
			"    public static MInt operator +(MInt a, long b) => a.Value + b;",
			"    public static MInt operator +(MInt a, int b) => a.Value + b;",
			"    public static MInt operator -(MInt a, MInt b) => a.Value - b.Value;",
			"    public static MInt operator -(MInt a, long b) => a.Value - b;",
			"    public static MInt operator -(MInt a, int b) => a.Value - b;",
			"    public static MInt operator *(MInt a, MInt b) => a.Value * b.Value;",
			"    public static MInt operator *(MInt a, long b) => a.Value * (b % Mod);",
			"    public static MInt operator *(MInt a, int b) => a.Value * (b % Mod);",
			"    public static MInt operator /(MInt a, MInt b) => a * b.Inverse();",
			"    public static MInt operator /(MInt a, long b) => a.Value * Inverse(b);",
			"    public static MInt operator /(MInt a, int b) => a.Value * Inverse(b);",
			"    public static bool operator ==(MInt a, MInt b) => a.Value == b.Value;",
			"    public static bool operator !=(MInt a, MInt b) => a.Value != b.Value;",
			"    public bool Equals(MInt other) => Value == other.Value;",
			"    public override bool Equals(object obj) => obj is MInt other && Equals(other);",
			"    public override int GetHashCode() => Value.GetHashCode();",
			"    public override string ToString() => Value.ToString();",
			"",
			"    public MInt Inverse() => Inverse(Value);",
			"",
			"    public static MInt Inverse(long a)",
			"    {",
			"        if (a == 0) return 0;",
			"        var p = Mod;",
			"        var (x1, y1, x2, y2) = (1L, 0L, 0L, 1L);",
			"        while (true)",
			"        {",
			"            if (p == 1) return (x2 % Mod + Mod) % Mod;",
			"            var div = a / p;",
			"            x1 -= x2 * div;",
			"            y1 -= y2 * div;",
			"            a %= p;",
			"            if (a == 1) return (x1 % Mod + Mod) % Mod;",
			"            div = p / a;",
			"            x2 -= x1 * div;",
			"            y2 -= y1 * div;",
			"            p %= a;",
			"        }",
			"    }",
			"",
			"    public MInt Power(long n) => Power(Value, n);",
			"",
			"    public static MInt Power(MInt x, long n)",
			"    {",
			"        if (n < 0) throw new ArgumentException();",
			"        var r = new MInt(1);",
			"        while (n > 0)",
			"        {",
			"            if ((n & 1) > 0) r *= x;",
			"            x *= x;",
			"            n >>= 1;",
			"        }",
			"",
			"        return r;",
			"    }",
			"",
			"    public static void SetMod(long m) => Mod = m;",
			"    public static void SetMod998244353() => SetMod(998244353);",
			"    public static void SetMod1000000007() => SetMod(1000000007);",
			"}"
		],
		"description": "Mod int struct"
	},
	"Enumeration": {
		"scope": "csharp",
		"prefix": "enumeration",
		"body": [
			"public static class Enumeration",
			"{",
			"    private static Dictionary<long, long> _memo = new Dictionary<long, long> { { 0, 1 }, { 1, 1 } };",
			"    private static Dictionary<long, long> _modMemo = new Dictionary<long, long> { { 0, 1 }, { 1, 1 } };",
			"    private static long _max = 1;",
			"    private static long _modMax = 1;",
			"",
			"    public static long Fractorial(long n)",
			"    {",
			"        if (_memo.ContainsKey(n)) return _memo[n];",
			"        if (n < 0) throw new ArgumentException();",
			"        var val = _memo[_max];",
			"        for (var i = _max + 1; i <= n; i++)",
			"        {",
			"            val *= i;",
			"            _memo[i] = val;",
			"        }",
			"        _max = n;",
			"        return _memo[n];",
			"    }",
			"",
			"    public static long Fractorial(long n, long mod)",
			"    {",
			"        if (_modMemo.ContainsKey(n)) return _modMemo[n];",
			"        if (n < 0) throw new ArgumentException();",
			"        var val = _modMemo[_modMax];",
			"        for (var i = _modMax + 1; i <= n; i++)",
			"        {",
			"            val *= i % mod;",
			"            val %= mod;",
			"            _modMemo[i] = val;",
			"        }",
			"        _modMax = n;",
			"        return _modMemo[n];",
			"    }",
			"",
			"    public static long PermutationCount(long n, long k)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        return Fractorial(n) / Fractorial(n - k);",
			"        // no memo",
			"        // var ret = 1L;",
			"        // for (var i = 0; i < k; i++) ret *= (n - i);",
			"        // return ret;",
			"    }",
			"",
			"    public static long PermutationCount(long n, long k, long mod)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        var top = Fractorial(n, mod);",
			"        var bottom = Fractorial(n - k, mod);",
			"        return (top * Power(bottom, mod - 2, mod)) % mod;",
			"        // no memo",
			"        // var ret = 1L;",
			"        // for (var i = 0; i < k; i++) ret = (ret * (n - i) % mod) % mod;",
			"        // return ret;",
			"    }",
			"",
			"    public static long CombinationCount(long n, long k)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        k = Math.Min(k, n - k);",
			"        return Fractorial(n) / (Fractorial(k) * Fractorial(n - k));",
			"        // no memo",
			"        // return PermutationCount(n, k) / PermutationCount(k, k);",
			"    }",
			"",
			"    public static long CombinationCount(long n, long k, long mod)",
			"    {",
			"        if (n < k) throw new ArgumentException();",
			"        k = Math.Min(k, n - k);",
			"        var top = Fractorial(n, mod);",
			"        var bottom = (Fractorial(k, mod) * Fractorial(n - k, mod)) % mod;",
			"        // no memo",
			"        // var top = PermutationCount(n, k, mod);",
			"        // var bottom = PermutationCount(k, k, mod);",
			"        return (top * Power(bottom, mod - 2, mod)) % mod;",
			"    }",
			"",
			"    public static long Power(long x, long y, long mod)",
			"    {",
			"        var result = 1L;",
			"        while (y > 0)",
			"        {",
			"            var xmod = x % mod;",
			"            if ((y & 1) == 1) result = (result * xmod) % mod;",
			"            x = (xmod * xmod) % mod;",
			"            y >>= 1;",
			"        }",
			"        return result;",
			"    }",
			"}"
		],
		"description": "Utility of enumeration"
	},
	"BinarySearch": {
		"scope": "csharp",
		"prefix": "binarysearch",
		"body": [
			"public static bool BinarySearch<T>(IEnumerable<T> items, T key, Comparer<T> comparer = null, int left = -1, int right = -1)",
			"{",
			"    return BinarySearch(items.ToArray(), key, comparer, left, right);",
			"}",
			"",
			"public static bool BinarySearch<T>(T[] items, T key, Comparer<T> comparer = null, int left = -1, int right = -1)",
			"{",
			"    comparer ??= Comparer<T>.Default;",
			"    var min = left < 0 ? 0 : left;",
			"    var max = right < 0 ? items.Length - 1 : right;",
			"    while (min <= max)",
			"    {",
			"        var mid = min + (max - min) / 2;",
			"        var result = comparer.Compare(items[mid], key);",
			"        if (result < 0) min = mid + 1;",
			"        else if (result > 0) max = mid - 1;",
			"        else return true;",
			"    }",
			"",
			"    return false;",
			"}"
		],
		"description": "Binary search"
	},
	"LowerBound": {
		"scope": "csharp",
		"prefix": "lowerbound",
		"body": [
			"public static int LowerBound<T>(IEnumerable<T> items, T key, Comparer<T> comparer = null)",
			"{",
			"    return LowerBound(items.ToArray(), key, comparer);",
			"}",
			"",
			"public static int LowerBound<T>(T[] items, T key, Comparer<T> comparer = null)",
			"{",
			"    comparer ??= Comparer<T>.Default;",
			"    var left = 0;",
			"    var right = items.Length - 1;",
			"    while (left <= right)",
			"    {",
			"        var mid = left + (right - left) / 2;",
			"        if (comparer.Compare(items[mid], key) == -1) left = mid + 1;",
			"        else right = mid - 1;",
			"    }",
			"",
			"    return left;",
			"}"
		],
		"description": "Lower bound"
	},
	"UpperBound": {
		"scope": "csharp",
		"prefix": "upperbound",
		"body": [
			"public static int UpperBound<T>(IEnumerable<T> items, T key, Comparer<T> comparer = null)",
			"{",
			"    return UpperBound(items.ToArray(), key, comparer);",
			"}",
			"",
			"public static int UpperBound<T>(T[] items, T key, Comparer<T> comparer = null)",
			"{",
			"    comparer ??= Comparer<T>.Default;",
			"    var left = 0;",
			"    var right = items.Length - 1;",
			"    while (left <= right)",
			"    {",
			"        var mid = left + (right - left) / 2;",
			"        if (comparer.Compare(items[mid], key) <= 0) left = mid + 1;",
			"        else right = mid - 1;",
			"    }",
			"",
			"    return left;",
			"}"
		],
		"description": "Upper bound"
	},
	"CumulativeSum": {
		"scope": "csharp",
		"prefix": "cumitems",
		"body": [
			"public static IEnumerable<long> CumulativeItems(IEnumerable<long> items)",
			"{",
			"    var arr = items.ToArray();",
			"    var ret = new long[arr.Length + 1];",
			"    for (var i = 0; i < arr.Length; i++) ret[i + 1] = arr[i] + ret[i];",
			"    return ret;",
			"}",
			"public static IEnumerable<long> CumulativeItems(IEnumerable<long> items, long mod)",
			"{",
			"    var arr = items.ToArray();",
			"    var ret = new long[arr.Length + 1];",
			"    for (var i = 0; i < arr.Length; i++) ret[i + 1] = (arr[i] + ret[i]) % mod;",
			"    return ret;",
			"}",
		],
		"description": "Cumulative sum of items"
	},
	"CountOf": {
		"scope": "csharp",
		"prefix": "countof",
		"body": [
			"static int CountOf(string target, string value)",
			"{",
			"    var editStr = target;",
			"    var count = 0;",
			"    var index = 0;",
			"    while (true)",
			"    {",
			"        index = editStr.IndexOf(value);",
			"        if (index < 0) break;",
			"        count++;",
			"        if (editStr.Length > 1) editStr = editStr.Substring(index + 1);",
			"    }",
			"    return count;",
			"}"
		],
		"description": "Count of a substring in a string"
	},
	"BitFullSearchEnumerable": {
		"scope": "csharp",
		"prefix": "bitfull",
		"body": [
			"static IEnumerable<bool[]> BitFullSearchEnumerable(int n)",
			"{",
			"    if (n < 0) yield return new bool[0];",
			"    for (var i = 0; i < Math.Pow(2, n); i++)",
			"    {",
			"        var array = new bool[n];",
			"        for (var j = 0; j < n; j++)",
			"        {",
			"            var right = (i >> j) & 1;",
			"            array[j] = right == 1;",
			"        }",
			"        yield return array;",
			"    }",
			"}"
		],
		"description": "Reverse string"
	},
	"UnionFind": {
		"scope": "csharp",
		"prefix": [
			"unionfind",
			"dsu"
		],
		"body": [
			"public class DSU",
			"{",
			"    private readonly int _n;",
			"    private readonly int[] _parentOrSize;",
			"",
			"    public DSU(int n = 0)",
			"    {",
			"        _n = n;",
			"        _parentOrSize = Enumerable.Repeat(-1, n).ToArray();",
			"    }",
			"",
			"    public int Merge(int a, int b)",
			"    {",
			"        if (a < 0 || _n <= a) throw new IndexOutOfRangeException(nameof(a));",
			"        if (b < 0 || _n <= b) throw new IndexOutOfRangeException(nameof(b));",
			"        var (x, y) = (LeaderOf(a), LeaderOf(b));",
			"        if (x == y) return x;",
			"        if (-_parentOrSize[x] < -_parentOrSize[y]) (x, y) = (y, x);",
			"        _parentOrSize[x] += _parentOrSize[y];",
			"        _parentOrSize[y] = x;",
			"        return x;",
			"    }",
			"",
			"    public bool IsSame(int a, int b)",
			"    {",
			"        if (a < 0 || _n <= a) throw new IndexOutOfRangeException(nameof(a));",
			"        if (b < 0 || _n <= b) throw new IndexOutOfRangeException(nameof(b));",
			"        return LeaderOf(a) == LeaderOf(b);",
			"    }",
			"",
			"    public int LeaderOf(int a)",
			"    {",
			"        if (a < 0 || _n <= a) throw new IndexOutOfRangeException(nameof(a));",
			"        if (_parentOrSize[a] < 0) return a;",
			"        return _parentOrSize[a] = LeaderOf(_parentOrSize[a]);",
			"    }",
			"",
			"    public int SizeOf(int a)",
			"    {",
			"        if (a < 0 || _n <= a) throw new IndexOutOfRangeException(nameof(a));",
			"        return -_parentOrSize[LeaderOf(a)];",
			"    }",
			"",
			"    public IEnumerable<IEnumerable<int>> Groups()",
			"    {",
			"        var leaders = new int[_n];",
			"        var groupSize = new int[_n];",
			"        for (var i = 0; i < _n; i++)",
			"        {",
			"            leaders[i] = LeaderOf(i);",
			"            groupSize[leaders[i]]++;",
			"        }",
			"",
			"        var ret = new List<int>[_n].Select(x => new List<int>()).ToArray();",
			"        for (var i = 0; i < _n; i++) ret[leaders[i]].Add(i);",
			"        return ret.Where(x => x.Any());",
			"    }",
			"}"
		],
		"description": "UnionFind tree class"
	},
	"Prime": {
		"scope": "csharp",
		"prefix": "prime",
		"body": [
			"public class Prime",
			"{",
			"    public Dictionary<long, long> Factors => new Dictionary<long, long>(_factors);",
			"    private Dictionary<long, long> _factors;",
			"    private static HashSet<long> _primes;",
			"    public Prime(long n)",
			"    {",
			"        if (_primes == null) _primes = new HashSet<long>();",
			"        _factors = new Dictionary<long, long>();",
			"        var tmp = n;",
			"        var max = (long)Math.Sqrt(n);",
			"        var p = 2;",
			"        while (p <= max)",
			"        {",
			"            if (tmp % p == 0)",
			"            {",
			"                _factors[p] = 0;",
			"                _primes.Add(p);",
			"                while (tmp % p == 0)",
			"                {",
			"                    tmp /= p;",
			"                    _factors[p]++;",
			"                }",
			"            }",
			"            p++;",
			"        }",
			"        if (tmp > 1)",
			"        {",
			"            _factors[tmp] = 1;",
			"            _primes.Add(tmp);",
			"        }",
			"    }",
			"    public bool IsPrime(long n)",
			"    {",
			"        if (_primes.Contains(n)) return true;",
			"        var p = new Prime(n);",
			"        return _primes.Contains(n);",
			"    }",
			"}"
		],
		"description": "Prime number class"
	},
	"SieveOfEratosthenes": {
		"scope": "csharp",
		"prefix": "sieve",
		"body": [
			"public static int[] SieveOfEratosthenes(int n)",
			"{",
			"    var length = (n + 1) / 2;",
			"    var sieve = n < 1024 ? stackalloc bool[length] : new bool[length];",
			"    sieve[0] = true;",
			"    var count = 1;",
			"    for (var i = 1; i < sieve.Length;)",
			"    {",
			"        for (var j = i; j < sieve.Length; j += i * 2 + 1) sieve[j] = true;",
			"        sieve[i] = false;",
			"        count++;",
			"        do i++;",
			"        while (i < sieve.Length && sieve[i]);",
			"    }",
			"",
			"    var primes = count < 1024 ? stackalloc int[count] : new int[count];",
			"    primes[0] = 2;",
			"    var index = 1;",
			"    for (var i = 0; i < sieve.Length; i++)",
			"    {",
			"        if (sieve[i]) continue;",
			"        primes[index] = i * 2 + 1;",
			"        index++;",
			"    }",
			"",
			"    return primes.ToArray();",
			"}"
		],
		"description": "Prime number class"
	},
	"LowestCommonAncestor": {
		"scope": "csharp",
		"prefix": "lca",
		"body": [
			"public class LowestCommonAncestor",
			"{",
			"    private List<int>[] G;",
			"    private int N;",
			"    private int _root;",
			"    private int _log;",
			"    private int[] _depth;",
			"    private int[][] _parents;",
			"",
			"    public LowestCommonAncestor(List<int>[] graph, int root = 0)",
			"    {",
			"        G = graph;",
			"        N = G.Length;",
			"        _root = root;",
			"        var tmp = N;",
			"        while (tmp > 0)",
			"        {",
			"            _log++;",
			"            tmp >>= 1;",
			"        }",
			"",
			"        _depth = new int[N];",
			"        _parents = new int[N][].Select(x => new int[_log]).ToArray();",
			"        var queue = new Queue<(int c, int p, int d)>();",
			"        queue.Enqueue((_root, -1, 0));",
			"        var used = new bool[N];",
			"        used[_root] = true;",
			"        while (queue.Any())",
			"        {",
			"            var item = queue.Dequeue();",
			"            var current = item.c;",
			"            var prev = item.p;",
			"            var distance = item.d;",
			"            _parents[current][0] = prev;",
			"            _depth[current] = distance;",
			"            foreach (var next in G[current])",
			"            {",
			"                if (used[next]) continue;",
			"                used[next] = true;",
			"                queue.Enqueue((next, current, distance + 1));",
			"            }",
			"        }",
			"",
			"        for (var i = 0; i + 1 < _log; i++)",
			"        {",
			"            for (var v = 0; v < N; v++)",
			"            {",
			"                var parent = _parents[v][i];",
			"                _parents[v][i + 1] = parent == -1 ? -1 : _parents[parent][i];",
			"            }",
			"        }",
			"    }",
			"",
			"    public int Find(int u, int v)",
			"    {",
			"        if (_depth[u] > _depth[v]) (u, v) = (v, u);",
			"        v = GetAncestor(v, _depth[v] - _depth[u]);",
			"        if (u == v) return u;",
			"        for (var i = _log - 1; i >= 0; i--)",
			"        {",
			"            if (_parents[u][i] != _parents[v][i]) (u, v) = (_parents[u][i], _parents[v][i]);",
			"        }",
			"        return _parents[u][0];",
			"    }",
			"",
			"    public int GetAncestor(int v, int h)",
			"    {",
			"        var parent = v;",
			"        for (var i = 0; i < _log; i++)",
			"        {",
			"            if ((h >> i & 1) == 1) parent = _parents[parent][i];",
			"        }",
			"        return parent;",
			"    }",
			"",
			"    public int GetDistance(int u, int v)",
			"    {",
			"        var p = Find(u, v);",
			"        return _depth[u] + _depth[v] - _depth[p] * 2;",
			"    }",
			"}"
		],
		"description": "lowest common ancestor"
	},
	"Graph": {
		"scope": "csharp",
		"prefix": "graph",
		"body": [
			"var G = new List<${2:int}>[${1:N}].Select(x => new List<${2:int}>()).ToArray();",
			"for (var i = 0; i < ${3:M}; i++)",
			"{",
			"    var (${3:a}, ${4:b}) = Scanner.Scan<${2}, ${2}>();",
			"    G[--${3}].Add(--${4});",
			"    G[${4}].Add(${3});",
			"}"
		],
		"description": "graph"
	},
	"Bfs": {
		"scope": "csharp",
		"prefix": "bfs",
		"body": [
			"var queue = new Queue<int>();",
			"queue.Enqueue(0);",
			"var depths = Enumerable.Repeat(-1, ${1:N}).ToArray();",
			"depths[0] = 0;",
			"while (queue.Any())",
			"{",
			"    var current = queue.Dequeue();",
			"    foreach (var next in G[current])",
			"    {",
			"        if (depths[next] != -1) continue;",
			"        depths[next] = depths[current] + 1;",
			"        queue.Enqueue(next);",
			"    }",
			"}"
		],
		"description": "breadth first search"
	},
	"Intersect": {
		"scope": "csharp",
		"prefix": "intersect",
		"body": [
			"public static bool Intersect(long ax, long ay, long bx, long by, long cx, long cy, long dx, long dy)",
			"{",
			"    var ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);",
			"    var tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);",
			"    var tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);",
			"    var td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);",
			"    return ta * tb < 0 && tc * td < 0;",
			"}"
		],
		"description": "check the lines are crossing."
	},
	"For": {
		"scope": "csharp",
		"prefix": "for",
		"body": [
			"for (var ${1:index} = ${2:start}; ${1:index} < ${3:end}; ${1:index}++)",
			"{",
			"    ${4:statement}",
			"}"
		],
		"description": "for statement"
	},
	"Out": {
		"scope": "csharp",
		"prefix": "out",
		"body": [
			"Console.WriteLine(${1});"
		],
		"description": "Output"
	},
	"TestMethod": {
		"scope": "csharp",
		"prefix": "testmethod",
		"body": [
			"[TestMethod]",
			"public void TestMethod${1:number}()",
			"{",
			"    var input = @\"\";",
			"    var output = @\"\";",
			"    Tester.InOutTest(() => Tasks.${2:task}.Solve(), input, output);",
			"}"
		],
		"description": "Output"
	},
}